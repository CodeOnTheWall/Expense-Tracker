{"ast":null,"code":"// injecting endpoints into our api to interact with backend api\nimport { apiSlice } from \"../../app/api/apiSlice\";\n\n// non api slice (not communicating with back end) that handles frontend state via reducer functions/action handlers\nimport { logOut, setCredentials } from \"./authSlice\";\n\n// requests to be sent to back end api which receive as responses\nexport const authApiSlice = apiSlice.injectEndpoints({\n  endpoints: builder => ({\n    login: builder.mutation({\n      // credentials is username and password that is sent with query\n      query: credentials => ({\n        url: \"/auth\",\n        method: \"POST\",\n        // object expected to be received by the backend, spreading out the credentials into the object\n        body: {\n          ...credentials\n        }\n      })\n    }),\n    sendLogout: builder.mutation({\n      query: () => ({\n        url: \"/auth/logout\",\n        method: \"POST\"\n      }),\n      // onQueryStarted is an rtkq function to call inside an endpoint, needs an arg at the beg, its required even if not used\n      // queryFulfilled to see if that finished\n      async onQueryStarted(arg, _ref) {\n        let {\n          dispatch,\n          queryFulfilled\n        } = _ref;\n        try {\n          // queryFulfilled waits for the req to be successfull (req to /auth/logout)\n          // its a promise that resolves when the req is successfull and res comes back\n          // if error and not resolves, catch error\n          await queryFulfilled;\n          // sets token to null in local state\n          dispatch(logOut());\n          // to get rid of subscription and 'clear' apiSlice as well, to clear out cache and query subscription\n          setTimeout(() => {\n            // util is a property of apiSlice that has utility functions, such as below to clear cache\n            dispatch(apiSlice.util.resetApiState());\n          }, 1000);\n        } catch (err) {\n          console.log(err);\n        }\n      }\n    }),\n    // sending a get req with a cookie with rT, to get a new aT\n    refresh: builder.mutation({\n      query: () => ({\n        url: \"/auth/refresh\",\n        method: \"GET\"\n      }),\n      async onQueryStarted(arg, _ref2) {\n        let {\n          dispatch,\n          queryFulfilled\n        } = _ref2;\n        try {\n          // data should be the aT\n          const {\n            data\n          } = await queryFulfilled;\n          // destructure\n          const {\n            accessToken\n          } = data;\n          // setting redux state with aT\n          dispatch(setCredentials({\n            accessToken\n          }));\n        } catch (err) {\n          console.log(err);\n        }\n      }\n    })\n  })\n});\n\n// use and Mutation are auto added\nexport const {\n  useLoginMutation,\n  useSendLogoutMutation,\n  useRefreshMutation\n} = authApiSlice;","map":{"version":3,"names":["apiSlice","logOut","setCredentials","authApiSlice","injectEndpoints","endpoints","builder","login","mutation","query","credentials","url","method","body","sendLogout","onQueryStarted","arg","dispatch","queryFulfilled","setTimeout","util","resetApiState","err","console","log","refresh","data","accessToken","useLoginMutation","useSendLogoutMutation","useRefreshMutation"],"sources":["C:/Users/Btrader/Documents/practice/expense-tracker-mern/frontend/src/features/auth/authApiSlice.js"],"sourcesContent":["// injecting endpoints into our api to interact with backend api\r\nimport { apiSlice } from \"../../app/api/apiSlice\";\r\n\r\n// non api slice (not communicating with back end) that handles frontend state via reducer functions/action handlers\r\nimport { logOut, setCredentials } from \"./authSlice\";\r\n\r\n// requests to be sent to back end api which receive as responses\r\nexport const authApiSlice = apiSlice.injectEndpoints({\r\n  endpoints: (builder) => ({\r\n    login: builder.mutation({\r\n      // credentials is username and password that is sent with query\r\n      query: (credentials) => ({\r\n        url: \"/auth\",\r\n        method: \"POST\",\r\n        // object expected to be received by the backend, spreading out the credentials into the object\r\n        body: { ...credentials },\r\n      }),\r\n    }),\r\n    sendLogout: builder.mutation({\r\n      query: () => ({\r\n        url: \"/auth/logout\",\r\n        method: \"POST\",\r\n      }),\r\n      // onQueryStarted is an rtkq function to call inside an endpoint, needs an arg at the beg, its required even if not used\r\n      // queryFulfilled to see if that finished\r\n      async onQueryStarted(arg, { dispatch, queryFulfilled }) {\r\n        try {\r\n          // queryFulfilled waits for the req to be successfull (req to /auth/logout)\r\n          // its a promise that resolves when the req is successfull and res comes back\r\n          // if error and not resolves, catch error\r\n          await queryFulfilled;\r\n          // sets token to null in local state\r\n          dispatch(logOut());\r\n          // to get rid of subscription and 'clear' apiSlice as well, to clear out cache and query subscription\r\n          setTimeout(() => {\r\n            // util is a property of apiSlice that has utility functions, such as below to clear cache\r\n            dispatch(apiSlice.util.resetApiState());\r\n          }, 1000);\r\n        } catch (err) {\r\n          console.log(err);\r\n        }\r\n      },\r\n    }),\r\n    // sending a get req with a cookie with rT, to get a new aT\r\n    refresh: builder.mutation({\r\n      query: () => ({\r\n        url: \"/auth/refresh\",\r\n        method: \"GET\",\r\n      }),\r\n      async onQueryStarted(arg, { dispatch, queryFulfilled }) {\r\n        try {\r\n          // data should be the aT\r\n          const { data } = await queryFulfilled;\r\n          // destructure\r\n          const { accessToken } = data;\r\n          // setting redux state with aT\r\n          dispatch(setCredentials({ accessToken }));\r\n        } catch (err) {\r\n          console.log(err);\r\n        }\r\n      },\r\n    }),\r\n  }),\r\n});\r\n\r\n// use and Mutation are auto added\r\nexport const { useLoginMutation, useSendLogoutMutation, useRefreshMutation } =\r\n  authApiSlice;\r\n"],"mappings":"AAAA;AACA,SAASA,QAAQ,QAAQ,wBAAwB;;AAEjD;AACA,SAASC,MAAM,EAAEC,cAAc,QAAQ,aAAa;;AAEpD;AACA,OAAO,MAAMC,YAAY,GAAGH,QAAQ,CAACI,eAAe,CAAC;EACnDC,SAAS,EAAGC,OAAO,KAAM;IACvBC,KAAK,EAAED,OAAO,CAACE,QAAQ,CAAC;MACtB;MACAC,KAAK,EAAGC,WAAW,KAAM;QACvBC,GAAG,EAAE,OAAO;QACZC,MAAM,EAAE,MAAM;QACd;QACAC,IAAI,EAAE;UAAE,GAAGH;QAAY;MACzB,CAAC;IACH,CAAC,CAAC;IACFI,UAAU,EAAER,OAAO,CAACE,QAAQ,CAAC;MAC3BC,KAAK,EAAE,OAAO;QACZE,GAAG,EAAE,cAAc;QACnBC,MAAM,EAAE;MACV,CAAC,CAAC;MACF;MACA;MACA,MAAMG,cAAc,CAACC,GAAG,QAAgC;QAAA,IAA9B;UAAEC,QAAQ;UAAEC;QAAe,CAAC;QACpD,IAAI;UACF;UACA;UACA;UACA,MAAMA,cAAc;UACpB;UACAD,QAAQ,CAAChB,MAAM,EAAE,CAAC;UAClB;UACAkB,UAAU,CAAC,MAAM;YACf;YACAF,QAAQ,CAACjB,QAAQ,CAACoB,IAAI,CAACC,aAAa,EAAE,CAAC;UACzC,CAAC,EAAE,IAAI,CAAC;QACV,CAAC,CAAC,OAAOC,GAAG,EAAE;UACZC,OAAO,CAACC,GAAG,CAACF,GAAG,CAAC;QAClB;MACF;IACF,CAAC,CAAC;IACF;IACAG,OAAO,EAAEnB,OAAO,CAACE,QAAQ,CAAC;MACxBC,KAAK,EAAE,OAAO;QACZE,GAAG,EAAE,eAAe;QACpBC,MAAM,EAAE;MACV,CAAC,CAAC;MACF,MAAMG,cAAc,CAACC,GAAG,SAAgC;QAAA,IAA9B;UAAEC,QAAQ;UAAEC;QAAe,CAAC;QACpD,IAAI;UACF;UACA,MAAM;YAAEQ;UAAK,CAAC,GAAG,MAAMR,cAAc;UACrC;UACA,MAAM;YAAES;UAAY,CAAC,GAAGD,IAAI;UAC5B;UACAT,QAAQ,CAACf,cAAc,CAAC;YAAEyB;UAAY,CAAC,CAAC,CAAC;QAC3C,CAAC,CAAC,OAAOL,GAAG,EAAE;UACZC,OAAO,CAACC,GAAG,CAACF,GAAG,CAAC;QAClB;MACF;IACF,CAAC;EACH,CAAC;AACH,CAAC,CAAC;;AAEF;AACA,OAAO,MAAM;EAAEM,gBAAgB;EAAEC,qBAAqB;EAAEC;AAAmB,CAAC,GAC1E3B,YAAY"},"metadata":{},"sourceType":"module"}