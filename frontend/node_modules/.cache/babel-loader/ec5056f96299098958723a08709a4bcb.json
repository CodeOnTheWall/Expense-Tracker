{"ast":null,"code":"import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\nimport { setCredentials } from \"../../features/auth/authSlice\";\n\n// By creating this baseQuery object, we are able to provide a default\n// configuration for all network requests made by the createApi function,\n// including the base URL and the authentication token header.\nconst baseQuery = fetchBaseQuery({\n  // base url for all req made by createApi\n  baseUrl: \"http://localhost:3000\",\n  // this property specifies whether cookies should be sent with the request.\n  credentials: \"include\",\n  // allows you to modify the headers of every request made by the createApi\n  // first checks current state of store using getState\n  prepareHeaders: (headers, _ref) => {\n    let {\n      getState\n    } = _ref;\n    // looking at current state, then auth state and getting current token and assigning that token\n    const token = getState().auth.token;\n\n    // if token, set headers\n    if (token) {\n      // specific format expected is 'Bearer token' - this sets authorization header\n      headers.set(\"authorization\", `Bearer ${token}`);\n    }\n    // now this is applied to every req sent\n    return headers;\n  }\n});\n\n// query wrapper\n// args (req url, method, and body), createApi object, extraOptions\nconst baseQueryWithReauth = async (args, api, extraOptions) => {\n  var _result, _result$error;\n  // await original req\n  let result = await baseQuery(args, api, extraOptions);\n\n  // trying original aT (if any) - if error, have to send a rT to get a new aT\n  if (((_result = result) === null || _result === void 0 ? void 0 : (_result$error = _result.error) === null || _result$error === void 0 ? void 0 : _result$error.status) === 403) {\n    console.log(\"sending refresh token\");\n\n    // send rT to get new aT\n    const refreshResult = await baseQuery(\"/auth/refresh\", api, extraOptions);\n\n    // data should hold access token\n    if (refreshResult !== null && refreshResult !== void 0 && refreshResult.data) {\n      // store the new token by spreading in the access token and set that token in redux state\n      api.dispatch(setCredentials({\n        ...refreshResult.data\n      }));\n\n      // essentially trying original aT, then send rT, and gives us new access token, with setCredentials\n      // after setting credentials, retry original query (args) with new access token\n      result = await baseQuery(args, api, extraOptions);\n    } else {\n      var _refreshResult$error;\n      // else we also dont have a rT\n      if ((refreshResult === null || refreshResult === void 0 ? void 0 : (_refreshResult$error = refreshResult.error) === null || _refreshResult$error === void 0 ? void 0 : _refreshResult$error.status) === 403) {\n        refreshResult.error.data.message = \"Your login has expired.\";\n      }\n      return refreshResult;\n    }\n  }\n  return result;\n};\n\n// baseQueryWithReauth is being passed as a param to createApi\n// default config for all network req\nexport const apiSlice = createApi({\n  // using baseQueryWithReauth as default for baseQuery\n  baseQuery: baseQueryWithReauth,\n  // for invalidating cached data\n  tagTypes: [\"Note\", \"User\"],\n  endpoints: builder => ({})\n});","map":{"version":3,"names":["createApi","fetchBaseQuery","setCredentials","baseQuery","baseUrl","credentials","prepareHeaders","headers","getState","token","auth","set","baseQueryWithReauth","args","api","extraOptions","result","error","status","console","log","refreshResult","data","dispatch","message","apiSlice","tagTypes","endpoints","builder"],"sources":["C:/Users/Btrader/Documents/practice/expense-tracker-mern/frontend/src/app/api/apiSlice.js"],"sourcesContent":["import { createApi, fetchBaseQuery } from \"@reduxjs/toolkit/query/react\";\r\n\r\nimport { setCredentials } from \"../../features/auth/authSlice\";\r\n\r\n// By creating this baseQuery object, we are able to provide a default\r\n// configuration for all network requests made by the createApi function,\r\n// including the base URL and the authentication token header.\r\nconst baseQuery = fetchBaseQuery({\r\n  // base url for all req made by createApi\r\n  baseUrl: \"http://localhost:3000\",\r\n\r\n  // this property specifies whether cookies should be sent with the request.\r\n  credentials: \"include\",\r\n\r\n  // allows you to modify the headers of every request made by the createApi\r\n  // first checks current state of store using getState\r\n  prepareHeaders: (headers, { getState }) => {\r\n    // looking at current state, then auth state and getting current token and assigning that token\r\n    const token = getState().auth.token;\r\n\r\n    // if token, set headers\r\n    if (token) {\r\n      // specific format expected is 'Bearer token' - this sets authorization header\r\n      headers.set(\"authorization\", `Bearer ${token}`);\r\n    }\r\n    // now this is applied to every req sent\r\n    return headers;\r\n  },\r\n});\r\n\r\n// query wrapper\r\n// args (req url, method, and body), createApi object, extraOptions\r\nconst baseQueryWithReauth = async (args, api, extraOptions) => {\r\n  // await original req\r\n  let result = await baseQuery(args, api, extraOptions);\r\n\r\n  // trying original aT (if any) - if error, have to send a rT to get a new aT\r\n  if (result?.error?.status === 403) {\r\n    console.log(\"sending refresh token\");\r\n\r\n    // send rT to get new aT\r\n    const refreshResult = await baseQuery(\"/auth/refresh\", api, extraOptions);\r\n\r\n    // data should hold access token\r\n    if (refreshResult?.data) {\r\n      // store the new token by spreading in the access token and set that token in redux state\r\n      api.dispatch(setCredentials({ ...refreshResult.data }));\r\n\r\n      // essentially trying original aT, then send rT, and gives us new access token, with setCredentials\r\n      // after setting credentials, retry original query (args) with new access token\r\n      result = await baseQuery(args, api, extraOptions);\r\n    } else {\r\n      // else we also dont have a rT\r\n      if (refreshResult?.error?.status === 403) {\r\n        refreshResult.error.data.message = \"Your login has expired.\";\r\n      }\r\n      return refreshResult;\r\n    }\r\n  }\r\n\r\n  return result;\r\n};\r\n\r\n// baseQueryWithReauth is being passed as a param to createApi\r\n// default config for all network req\r\nexport const apiSlice = createApi({\r\n  // using baseQueryWithReauth as default for baseQuery\r\n  baseQuery: baseQueryWithReauth,\r\n  // for invalidating cached data\r\n  tagTypes: [\"Note\", \"User\"],\r\n  endpoints: (builder) => ({}),\r\n});\r\n"],"mappings":"AAAA,SAASA,SAAS,EAAEC,cAAc,QAAQ,8BAA8B;AAExE,SAASC,cAAc,QAAQ,+BAA+B;;AAE9D;AACA;AACA;AACA,MAAMC,SAAS,GAAGF,cAAc,CAAC;EAC/B;EACAG,OAAO,EAAE,uBAAuB;EAEhC;EACAC,WAAW,EAAE,SAAS;EAEtB;EACA;EACAC,cAAc,EAAE,CAACC,OAAO,WAAmB;IAAA,IAAjB;MAAEC;IAAS,CAAC;IACpC;IACA,MAAMC,KAAK,GAAGD,QAAQ,EAAE,CAACE,IAAI,CAACD,KAAK;;IAEnC;IACA,IAAIA,KAAK,EAAE;MACT;MACAF,OAAO,CAACI,GAAG,CAAC,eAAe,EAAG,UAASF,KAAM,EAAC,CAAC;IACjD;IACA;IACA,OAAOF,OAAO;EAChB;AACF,CAAC,CAAC;;AAEF;AACA;AACA,MAAMK,mBAAmB,GAAG,OAAOC,IAAI,EAAEC,GAAG,EAAEC,YAAY,KAAK;EAAA;EAC7D;EACA,IAAIC,MAAM,GAAG,MAAMb,SAAS,CAACU,IAAI,EAAEC,GAAG,EAAEC,YAAY,CAAC;;EAErD;EACA,IAAI,YAAAC,MAAM,6DAAN,QAAQC,KAAK,kDAAb,cAAeC,MAAM,MAAK,GAAG,EAAE;IACjCC,OAAO,CAACC,GAAG,CAAC,uBAAuB,CAAC;;IAEpC;IACA,MAAMC,aAAa,GAAG,MAAMlB,SAAS,CAAC,eAAe,EAAEW,GAAG,EAAEC,YAAY,CAAC;;IAEzE;IACA,IAAIM,aAAa,aAAbA,aAAa,eAAbA,aAAa,CAAEC,IAAI,EAAE;MACvB;MACAR,GAAG,CAACS,QAAQ,CAACrB,cAAc,CAAC;QAAE,GAAGmB,aAAa,CAACC;MAAK,CAAC,CAAC,CAAC;;MAEvD;MACA;MACAN,MAAM,GAAG,MAAMb,SAAS,CAACU,IAAI,EAAEC,GAAG,EAAEC,YAAY,CAAC;IACnD,CAAC,MAAM;MAAA;MACL;MACA,IAAI,CAAAM,aAAa,aAAbA,aAAa,+CAAbA,aAAa,CAAEJ,KAAK,yDAApB,qBAAsBC,MAAM,MAAK,GAAG,EAAE;QACxCG,aAAa,CAACJ,KAAK,CAACK,IAAI,CAACE,OAAO,GAAG,yBAAyB;MAC9D;MACA,OAAOH,aAAa;IACtB;EACF;EAEA,OAAOL,MAAM;AACf,CAAC;;AAED;AACA;AACA,OAAO,MAAMS,QAAQ,GAAGzB,SAAS,CAAC;EAChC;EACAG,SAAS,EAAES,mBAAmB;EAC9B;EACAc,QAAQ,EAAE,CAAC,MAAM,EAAE,MAAM,CAAC;EAC1BC,SAAS,EAAGC,OAAO,KAAM,CAAC,CAAC;AAC7B,CAAC,CAAC"},"metadata":{},"sourceType":"module"}