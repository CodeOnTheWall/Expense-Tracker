{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Btrader\\\\Documents\\\\practice\\\\expense-tracker-mern\\\\frontend\\\\src\\\\features\\\\auth\\\\Login.js\",\n  _s = $RefreshSig$();\n// use useReducer when you update a state that depends on another state to avoid problems\n\nimport React, { useState, useEffect, useReducer, useRef } from \"react\";\n// our hooks\n// useState to manage our formIsValid state, which essentially wont allow us to login unless we are valid\n// useEffect stops constant rendering for us and only renders intially and then after emailIsValid/passwordIsValid\n// useReducer is better state management\n// useRef to focus a particular field\n\n// redux\nimport { useDispatch } from \"react-redux\";\n// non api slice\nimport { setCredentials } from \"./authSlice\";\n// api slice to talk to backend\nimport { useLoginMutation } from \"./authApiSlice\";\nimport Card from \"../../components/UI/Card/Card\";\nimport classes from \"./Login.module.css\";\nimport Button from \"../../components/UI/Button/Button\";\nimport Input from \"../../components/UI/Input/input\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nconst ACTIONS = {\n  USERINPUT: \"USERINPUT\",\n  INPUTBLUR: \"INPUTBLUR\"\n};\n\n// REDUCERS\n// the 2 below reducers allow us to manage both the value and validity (isValid) into one state, managed by useReducer, whenever we receive user input action\n// reducerFn(s), in this case emailReducer, will automatically get the most recent state snapshot from react (param of state)\n// reducerFn(s) can be outside the functional component\n// when a dispatchFn is called, react will call reducerFn's and then the reducerFn will match the if with the info of the passed in action,\n// and return a new state (via passing emailReducer into useReducer which updates state, and clears the dispatch for more dispatches to come)\nconst emailReducer = (state, action) => {\n  // the state will contain value and isValid\n  if (action.type === ACTIONS.USERINPUT) {\n    return {\n      value: action.emailInputValue,\n      isValid: action.emailInputValue.includes(\"@\")\n    };\n  }\n  if (action.type === ACTIONS.INPUTBLUR) {\n    return {\n      value: state.value,\n      isValid: state.value.includes(\"@\")\n    };\n  }\n  return {\n    value: \"\",\n    isValid: false\n  };\n};\nconst passwordReducer = (state, action) => {\n  if (action.type === ACTIONS.USERINPUT) {\n    return {\n      value: action.passwordInputValue,\n      isValid: action.passwordInputValue.trim().length > 6\n    };\n  }\n  if (action.type === ACTIONS.INPUTBLUR) {\n    return {\n      value: state.value,\n      isValid: state.value.trim().length > 6\n    };\n  }\n  return {\n    value: \"\",\n    isValid: false\n  };\n};\nconst Login = () => {\n  _s();\n  // REFS to set focus\n  const errRef = useRef();\n  const emailInputRef = useRef();\n  const passwordInputRef = useRef();\n\n  // STATES\n  const [formIsValid, setFormIsValid] = useState(false);\n  // useReducer always returns an array with exactly 2 values, which below we destructure to get emailState and dispatchEmail\n  // this is better state management, so first value (emailState) is latest state snapshot, and second value is a function that allows us to update that state snapshot\n  // after onChange or onBlur, that goes to their relative handlers, which then dispatch the data to the reducer funcs, which then update the state here\n  const [emailState, dispatchEmail] = useReducer(emailReducer, {\n    value: \"\",\n    isValid: null\n  });\n  // onChange event occurs, pointing to emailChangeHandler, in turn forwards that dispatchEmail to emailReducer, which in turn returns new state\n  // this state will be passed into useReducer, which in turn gives us again a new destructured array with new emailState and another dispatchEmail\n  const [passwordState, dispatchPassword] = useReducer(passwordReducer, {\n    value: \"\",\n    isValid: null\n  });\n  const [errMsg, setErrMsg] = useState(\"\");\n  const dispatch = useDispatch();\n\n  // login here is essentially the mutation func from authApiSlice auth/login\n  // isLoading is auto given from rtkq to indicate if req is still loading\n  const [login, {\n    isLoading\n  }] = useLoginMutation();\n\n  // these new consts (emailIsValid and passwordIsValid) imply that the state isValid:true, via object destructuring\n  // so now our useEffect will only run the first render, but then after that only when we have valid inputs\n  // this stops excess re rendering and use of our useEffect\n  const {\n    isValid: emailIsValid\n  } = emailState;\n  const {\n    isValid: passwordIsValid\n  } = passwordState;\n\n  // USEEFFECT\n  // focuses the input only when component loads (empty dependency [])\n  useEffect(() => {\n    emailInputRef.current.focus();\n  }, []);\n\n  // clear out error message when username or password changes\n  // user may have read error, so when they go to continue typing, error should go away\n  useEffect(() => {\n    setErrMsg(\"\");\n  }, [emailState, passwordState]);\n\n  // useEffect with dependencies i.e. [enteredEmail, enteredPassword] will work after inital render of the component\n  // and it will always be re triggered/re executed on change of one of the listed dependencies\n  // useEffect always runs after everything else inside the functional component runs\n  useEffect(() => {\n    // useEffect helps us deal with code that should be executed in response to something else\n    // in this example, the button going from disabled to enabled (formisValid from false to true)\n    const identifier = setTimeout(() => {\n      console.log(\"Checking form validity!\");\n      setFormIsValid(emailIsValid && passwordIsValid\n      // setFormIsValid will only run 2 second after, if emailIsValid and passwordIsValid, which are consts that already imply isValid: true\n      );\n    }, 2000);\n    // we can use this identifier to clear this timer - after 1 sec setFormIsValid will run\n    return () => {\n      console.log(\"clean up\");\n      clearTimeout(identifier);\n      // this is the cleanup function that will clear the timer on setTimout\n    };\n  }, [emailIsValid, passwordIsValid]);\n\n  // HANDLERS TO DISPATCH ACTIONS\n  // passing dispatchEmail an action, which is always consumed/passed into first arg of useReducer (in this case emailReducer)\n  // our type field describes what happened, and emailInputValue is the value the user entered\n  // so now we will send type and emailInputValue as an action to be passed into emailReducer\n  // this action is sent as an object\n  const emailChangeHandler = event => {\n    dispatchEmail({\n      type: ACTIONS.USERINPUT,\n      emailInputValue: event.target.value\n    });\n  };\n  const passwordChangeHandler = event => {\n    dispatchPassword({\n      type: ACTIONS.USERINPUT,\n      passwordInputValue: event.target.value\n    });\n  };\n  // dont need to add a val here as all we care about is that input lost focus\n  const validateEmailHandler = () => {\n    dispatchEmail({\n      type: ACTIONS.INPUTBLUR\n    });\n  };\n  const validatePasswordHandler = () => {\n    dispatchPassword({\n      type: ACTIONS.INPUTBLUR\n    });\n  };\n  const submitHandler = async event => {\n    event.preventDefault();\n    if (formIsValid) {\n      try {\n        const {\n          accessToken\n        } = await login({\n          emailState,\n          passwordState\n        }).unwrap();\n        dispatch(setCredentials({\n          accessToken\n        }));\n        // do the bottom 2 matter? state will change and show different screen anyways\n        // setEmailState(\"\");\n        // setPasswordState(\"\");\n      } catch (err) {\n        if (!err.status) {\n          setErrMsg(\"No Server Response\");\n        } else if (err.status === 400) {\n          setErrMsg(\"Missing Username or Password\");\n        } else if (err.status === 401) {\n          setErrMsg(\"Unauthorized\");\n        } else {\n          var _err$data;\n          setErrMsg((_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.message);\n        }\n        errRef.current.focus();\n      }\n    } else if (!emailIsValid) {\n      emailInputRef.current.focus();\n      // if formIsValid is false, i want to focus the first input i find\n    } else {\n      passwordInputRef.current.focus();\n    }\n  };\n\n  // if errMsg ? apply errmsg class, otherwise apply offscreen class\n  // const errClass = errMsg ? \"errmsg\" : \"offscreen\";\n\n  // isLoading 'state' from login func\n  if (isLoading) return /*#__PURE__*/_jsxDEV(\"p\", {\n    children: \"Loading...\"\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 189,\n    columnNumber: 25\n  }, this);\n  const content = /*#__PURE__*/_jsxDEV(Card, {\n    className: classes.login,\n    children: [/*#__PURE__*/_jsxDEV(\"p\", {\n      ref: errRef,\n      \"aria-live\": \"assertive\",\n      children: errMsg\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"form\", {\n      onSubmit: submitHandler,\n      children: [/*#__PURE__*/_jsxDEV(Input, {\n        className: classes.control,\n        ref: emailInputRef,\n        id: \"email\"\n        // this is what is the label title\n        ,\n        label: \"E-Mail\",\n        type: \"email\",\n        isValid: emailIsValid,\n        value: emailState.value,\n        onChange: emailChangeHandler,\n        onBlur: validateEmailHandler\n        // onBlur even occurs when an object loses focus\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 199,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(Input, {\n        className: classes.control,\n        ref: passwordInputRef,\n        id: \"password\",\n        label: \"password\",\n        type: \"password\",\n        isValid: passwordIsValid,\n        value: passwordState.value,\n        onChange: passwordChangeHandler,\n        onBlur: validatePasswordHandler\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 212,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: classes.actions,\n        children: [/*#__PURE__*/_jsxDEV(Button, {\n          type: \"submit\",\n          children: \"Login\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 224,\n          columnNumber: 11\n        }, this), /*#__PURE__*/_jsxDEV(Button, {\n          type: \"submit\",\n          children: \"Sign Up!\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 228,\n          columnNumber: 11\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 223,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 198,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 192,\n    columnNumber: 5\n  }, this);\n  return content;\n};\n_s(Login, \"DVrR1knO9jLvylshNA/SMIpl7rk=\", false, function () {\n  return [useDispatch, useLoginMutation];\n});\n_c = Login;\nexport default Login;\nvar _c;\n$RefreshReg$(_c, \"Login\");","map":{"version":3,"names":["React","useState","useEffect","useReducer","useRef","useDispatch","setCredentials","useLoginMutation","Card","classes","Button","Input","ACTIONS","USERINPUT","INPUTBLUR","emailReducer","state","action","type","value","emailInputValue","isValid","includes","passwordReducer","passwordInputValue","trim","length","Login","errRef","emailInputRef","passwordInputRef","formIsValid","setFormIsValid","emailState","dispatchEmail","passwordState","dispatchPassword","errMsg","setErrMsg","dispatch","login","isLoading","emailIsValid","passwordIsValid","current","focus","identifier","setTimeout","console","log","clearTimeout","emailChangeHandler","event","target","passwordChangeHandler","validateEmailHandler","validatePasswordHandler","submitHandler","preventDefault","accessToken","unwrap","err","status","data","message","content","control","actions"],"sources":["C:/Users/Btrader/Documents/practice/expense-tracker-mern/frontend/src/features/auth/Login.js"],"sourcesContent":["// use useReducer when you update a state that depends on another state to avoid problems\r\n\r\nimport React, { useState, useEffect, useReducer, useRef } from \"react\";\r\n// our hooks\r\n// useState to manage our formIsValid state, which essentially wont allow us to login unless we are valid\r\n// useEffect stops constant rendering for us and only renders intially and then after emailIsValid/passwordIsValid\r\n// useReducer is better state management\r\n// useRef to focus a particular field\r\n\r\n// redux\r\nimport { useDispatch } from \"react-redux\";\r\n// non api slice\r\nimport { setCredentials } from \"./authSlice\";\r\n// api slice to talk to backend\r\nimport { useLoginMutation } from \"./authApiSlice\";\r\n\r\nimport Card from \"../../components/UI/Card/Card\";\r\nimport classes from \"./Login.module.css\";\r\nimport Button from \"../../components/UI/Button/Button\";\r\nimport Input from \"../../components/UI/Input/input\";\r\n\r\nconst ACTIONS = {\r\n  USERINPUT: \"USERINPUT\",\r\n  INPUTBLUR: \"INPUTBLUR\",\r\n};\r\n\r\n// REDUCERS\r\n// the 2 below reducers allow us to manage both the value and validity (isValid) into one state, managed by useReducer, whenever we receive user input action\r\n// reducerFn(s), in this case emailReducer, will automatically get the most recent state snapshot from react (param of state)\r\n// reducerFn(s) can be outside the functional component\r\n// when a dispatchFn is called, react will call reducerFn's and then the reducerFn will match the if with the info of the passed in action,\r\n// and return a new state (via passing emailReducer into useReducer which updates state, and clears the dispatch for more dispatches to come)\r\nconst emailReducer = (state, action) => {\r\n  // the state will contain value and isValid\r\n  if (action.type === ACTIONS.USERINPUT) {\r\n    return {\r\n      value: action.emailInputValue,\r\n      isValid: action.emailInputValue.includes(\"@\"),\r\n    };\r\n  }\r\n  if (action.type === ACTIONS.INPUTBLUR) {\r\n    return { value: state.value, isValid: state.value.includes(\"@\") };\r\n  }\r\n  return { value: \"\", isValid: false };\r\n};\r\n\r\nconst passwordReducer = (state, action) => {\r\n  if (action.type === ACTIONS.USERINPUT) {\r\n    return {\r\n      value: action.passwordInputValue,\r\n      isValid: action.passwordInputValue.trim().length > 6,\r\n    };\r\n  }\r\n  if (action.type === ACTIONS.INPUTBLUR) {\r\n    return { value: state.value, isValid: state.value.trim().length > 6 };\r\n  }\r\n  return { value: \"\", isValid: false };\r\n};\r\n\r\nconst Login = () => {\r\n  // REFS to set focus\r\n  const errRef = useRef();\r\n  const emailInputRef = useRef();\r\n  const passwordInputRef = useRef();\r\n\r\n  // STATES\r\n  const [formIsValid, setFormIsValid] = useState(false);\r\n  // useReducer always returns an array with exactly 2 values, which below we destructure to get emailState and dispatchEmail\r\n  // this is better state management, so first value (emailState) is latest state snapshot, and second value is a function that allows us to update that state snapshot\r\n  // after onChange or onBlur, that goes to their relative handlers, which then dispatch the data to the reducer funcs, which then update the state here\r\n  const [emailState, dispatchEmail] = useReducer(emailReducer, {\r\n    value: \"\",\r\n    isValid: null,\r\n  });\r\n  // onChange event occurs, pointing to emailChangeHandler, in turn forwards that dispatchEmail to emailReducer, which in turn returns new state\r\n  // this state will be passed into useReducer, which in turn gives us again a new destructured array with new emailState and another dispatchEmail\r\n  const [passwordState, dispatchPassword] = useReducer(passwordReducer, {\r\n    value: \"\",\r\n    isValid: null,\r\n  });\r\n  const [errMsg, setErrMsg] = useState(\"\");\r\n\r\n  const dispatch = useDispatch();\r\n\r\n  // login here is essentially the mutation func from authApiSlice auth/login\r\n  // isLoading is auto given from rtkq to indicate if req is still loading\r\n  const [login, { isLoading }] = useLoginMutation();\r\n\r\n  // these new consts (emailIsValid and passwordIsValid) imply that the state isValid:true, via object destructuring\r\n  // so now our useEffect will only run the first render, but then after that only when we have valid inputs\r\n  // this stops excess re rendering and use of our useEffect\r\n  const { isValid: emailIsValid } = emailState;\r\n  const { isValid: passwordIsValid } = passwordState;\r\n\r\n  // USEEFFECT\r\n  // focuses the input only when component loads (empty dependency [])\r\n  useEffect(() => {\r\n    emailInputRef.current.focus();\r\n  }, []);\r\n\r\n  // clear out error message when username or password changes\r\n  // user may have read error, so when they go to continue typing, error should go away\r\n  useEffect(() => {\r\n    setErrMsg(\"\");\r\n  }, [emailState, passwordState]);\r\n\r\n  // useEffect with dependencies i.e. [enteredEmail, enteredPassword] will work after inital render of the component\r\n  // and it will always be re triggered/re executed on change of one of the listed dependencies\r\n  // useEffect always runs after everything else inside the functional component runs\r\n  useEffect(() => {\r\n    // useEffect helps us deal with code that should be executed in response to something else\r\n    // in this example, the button going from disabled to enabled (formisValid from false to true)\r\n    const identifier = setTimeout(() => {\r\n      console.log(\"Checking form validity!\");\r\n      setFormIsValid(\r\n        emailIsValid && passwordIsValid\r\n        // setFormIsValid will only run 2 second after, if emailIsValid and passwordIsValid, which are consts that already imply isValid: true\r\n      );\r\n    }, 2000);\r\n    // we can use this identifier to clear this timer - after 1 sec setFormIsValid will run\r\n    return () => {\r\n      console.log(\"clean up\");\r\n      clearTimeout(identifier);\r\n      // this is the cleanup function that will clear the timer on setTimout\r\n    };\r\n  }, [emailIsValid, passwordIsValid]);\r\n\r\n  // HANDLERS TO DISPATCH ACTIONS\r\n  // passing dispatchEmail an action, which is always consumed/passed into first arg of useReducer (in this case emailReducer)\r\n  // our type field describes what happened, and emailInputValue is the value the user entered\r\n  // so now we will send type and emailInputValue as an action to be passed into emailReducer\r\n  // this action is sent as an object\r\n  const emailChangeHandler = (event) => {\r\n    dispatchEmail({\r\n      type: ACTIONS.USERINPUT,\r\n      emailInputValue: event.target.value,\r\n    });\r\n  };\r\n  const passwordChangeHandler = (event) => {\r\n    dispatchPassword({\r\n      type: ACTIONS.USERINPUT,\r\n      passwordInputValue: event.target.value,\r\n    });\r\n  };\r\n  // dont need to add a val here as all we care about is that input lost focus\r\n  const validateEmailHandler = () => {\r\n    dispatchEmail({ type: ACTIONS.INPUTBLUR });\r\n  };\r\n  const validatePasswordHandler = () => {\r\n    dispatchPassword({ type: ACTIONS.INPUTBLUR });\r\n  };\r\n\r\n  const submitHandler = async (event) => {\r\n    event.preventDefault();\r\n    if (formIsValid) {\r\n      try {\r\n        const { accessToken } = await login({\r\n          emailState,\r\n          passwordState,\r\n        }).unwrap();\r\n        dispatch(setCredentials({ accessToken }));\r\n        // do the bottom 2 matter? state will change and show different screen anyways\r\n        // setEmailState(\"\");\r\n        // setPasswordState(\"\");\r\n      } catch (err) {\r\n        if (!err.status) {\r\n          setErrMsg(\"No Server Response\");\r\n        } else if (err.status === 400) {\r\n          setErrMsg(\"Missing Username or Password\");\r\n        } else if (err.status === 401) {\r\n          setErrMsg(\"Unauthorized\");\r\n        } else {\r\n          setErrMsg(err.data?.message);\r\n        }\r\n        errRef.current.focus();\r\n      }\r\n    } else if (!emailIsValid) {\r\n      emailInputRef.current.focus();\r\n      // if formIsValid is false, i want to focus the first input i find\r\n    } else {\r\n      passwordInputRef.current.focus();\r\n    }\r\n  };\r\n\r\n  // if errMsg ? apply errmsg class, otherwise apply offscreen class\r\n  // const errClass = errMsg ? \"errmsg\" : \"offscreen\";\r\n\r\n  // isLoading 'state' from login func\r\n  if (isLoading) return <p>Loading...</p>;\r\n\r\n  const content = (\r\n    <Card className={classes.login}>\r\n      {/* aria-live monitors element for changes, and reads aloud as a screen reader,\r\n        assertive will immediately announce updates */}\r\n      <p ref={errRef} aria-live=\"assertive\">\r\n        {errMsg}\r\n      </p>\r\n      <form onSubmit={submitHandler}>\r\n        <Input\r\n          className={classes.control}\r\n          ref={emailInputRef}\r\n          id=\"email\"\r\n          // this is what is the label title\r\n          label=\"E-Mail\"\r\n          type=\"email\"\r\n          isValid={emailIsValid}\r\n          value={emailState.value}\r\n          onChange={emailChangeHandler}\r\n          onBlur={validateEmailHandler}\r\n          // onBlur even occurs when an object loses focus\r\n        />\r\n        <Input\r\n          className={classes.control}\r\n          ref={passwordInputRef}\r\n          id=\"password\"\r\n          label=\"password\"\r\n          type=\"password\"\r\n          isValid={passwordIsValid}\r\n          value={passwordState.value}\r\n          onChange={passwordChangeHandler}\r\n          onBlur={validatePasswordHandler}\r\n        />\r\n        <div className={classes.actions}>\r\n          <Button type=\"submit\">\r\n            {/* formIsValid starts at false, so !false is true, hence button is disabled */}\r\n            Login\r\n          </Button>\r\n          <Button type=\"submit\">\r\n            {/* formIsValid starts at false, so !false is true, hence button is disabled */}\r\n            Sign Up!\r\n          </Button>\r\n        </div>\r\n      </form>\r\n    </Card>\r\n  );\r\n\r\n  return content;\r\n};\r\n\r\nexport default Login;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}